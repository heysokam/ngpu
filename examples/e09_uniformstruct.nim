#:____________________________________________________
#  ngpu  |  Copyright (C) Ivan Mar (sOkam!)  |  MIT  |
#:____________________________________________________
# Uniform struct example                            |
# Current time can be accessed in shader code.      |
# The Uniform struct also contains a color uniform  |
#___________________________________________________|
# n*dk dependencies
import nstd
import nmath
import nsys
# n*gpu dependencies
import ngpu
# Examples dependencies
import ./cfg
import ./state as e


#__________________
# Dependencies specific to this example
from nglfw as glfw import nil
import ngpu/tech/shared/gen

#_____________________________
# Triangle shader
#   The `u` variable and its struct type are generated by ngpu,
#   by registering our Uniforms variable.
#   Their code will be automatically added at the top of our shader.
#   Its fields and type will have the same names as our Nim object.
#__________________
type Uniforms = object         # Our uniform struct type. All fields must be aligned to the size of a Vec4 (aka 16)
  time  {.align(16).}:float32  # Mark as align(16) in this variable is not needed, since its 0. Just for clarity
  color {.align(16).}:Color    # Mark as align(16), so that the time field gets padded.
var u = Uniforms(
  time  : glfw.getTime().float32,
  color : color(0,1,0,1),
  ) # << Uniforms( ... )
#__________________
const shaderCode = """
// We don't add any code for the Uniforms struct variable "u",
// but it will be available for use in the shader.

struct VertIn {
  @builtin(vertex_index) id :u32,
  @location(0) pos   :vec3<f32>,
  @location(1) color :vec4<f32>,
  @location(2) uv    :vec2<f32>,
  @location(3) norm  :vec3<f32>,
}
struct VertOut {
  @builtin(position) pos   :vec4<f32>,
  @location(0)       color :vec4<f32>,
  @location(1)       uv    :vec2<f32>,
  @location(2)       norm  :vec3<f32>,
}
@vertex fn vert(in :VertIn) ->VertOut {
  // Add the uniform variable to the position of this vertex
  let offset = 0.3 * vec3<f32>(cos(u.time), sin(u.time), 0.0);  // Calculate the (x,y) offset
  let pos    = in.pos + offset;                                 // Move the vertex position using the offset
  // Define the output of the vertex shader
  var out   :VertOut;
  out.pos   = vec4<f32>(pos, 1.0);
  out.color = in.color;  // Forward the color attribute to the fragment shader
  out.uv    = in.uv;     // Forward the texture coordinates to the fragment shader
  out.norm  = in.norm;   // Forward the vertex normal to the fragment shader
  return out;
}

@fragment fn frag(in :VertOut) ->@location(0) vec4<f32> {
  return vec4<f32>(u.color.r, u.color.g, u.color.b, in.color.a);
}
"""
import ngpu/tech/shared/data # TODO: This should be imported auto, but missing RenderData.new( ... )

#________________________________________________
# Entry Point
#__________________
proc run=
  echo cfg.Prefix&" | Hello Uniform"
  #__________________
  # Init the window+input and Renderer
  e.sys    = nsys.init(cfg.res, title = cfg.Prefix&" | Hello Uniform") # << state.sys.init()
  e.render = ngpu.new(Renderer, system = e.sys, label = cfg.Prefix) # << state.render.init()
  #__________________
  # Init the Data, Mesh and Technique
  var uniform  = e.render.new(RenderData[Uniforms], u, "u")  # Create the RenderData  (aka uniform)
  var triangle = e.render.new(RenderMesh, gen.triangle())    # Create the RenderMesh
  var tech     = e.render.init(Tech.Simple,
    code = shaderCode,
    data = (uniform,).mvar, # The simple tech only accepts a tuple of Group.global data
    ) # << Tech.Simple.init( ... )
  e.render.upload(triangle)
  e.render.upload(uniform)  # Explicit upload step. Could be done when creating the data (with upload = true)
  #__________________
  # Update loop
  while not e.sys.close():
    e.sys.update()
    # Update the uniform contents
    u.time = glfw.getTime().float32
    e.render.update(uniform, u)
    # Render this mesh, with this style
    e.render.draw(triangle, tech)  # (note: uses any global data contained in the style)
  #__________________
  # Terminate
  e.render.term()
  e.sys.term()


#________________________________________________
when isMainModule: run()

