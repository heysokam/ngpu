#:____________________________________________________
#  ngpu  |  Copyright (C) Ivan Mar (sOkam!)  |  MIT  |
#:____________________________________________________
# Single Texture example                              |
# Our byte array can be accessed from the shader.     |
# The position is fixed to the topleft of the screen  |
# Triangle UVs are not used in this example           |
#_____________________________________________________|
# std dependencies
import std/sequtils
# ndk dependencies
import nstd
import nmath
# ngpu dependencies
import ngpu
# Examples dependencies
import ./cfg
import ./state as e

#__________________
# Inputs
from nglfw as glfw import nil
proc key (win :glfw.Window; key, code, action, mods :cint) :void {.cdecl.}=
  ## GLFW Keyboard Input Callback
  if (key == glfw.KeyEscape and action == glfw.Press):
    glfw.setWindowShouldClose(win, true)


#__________________
# Dependencies specific to this example
import ngpu/tech/shared/gen

#_____________________________
# Triangle shader
#   The `u` variable and its struct type are generated by ngpu,
#   by registering our Uniforms variable.
#   Their code will be automatically added at the top of our shader.
#   Its fields and type will have the same names as our Nim object.
#__________________
type Uniforms = object         # Our uniform struct type. All fields must be aligned to the size of a Vec4 (aka 16)
  time  {.align(16).}:float32  # Mark as align(16) in this variable is not needed, since its 0. Just for clarity
  color {.align(16).}:Color    # Mark as align(16), so that the time field gets padded.
var u = Uniforms(
  time  : glfw.getTime().float32,
  color : color(0,1,0,1),
  ) # << Uniforms( ... )
# Generate a fully white Image for the texture
let pix = newSeqWith[ColorRGBX](512*512, color(1,1,1,1).rgbx())
var img = Image(width:512, height:512, data:pix)
#__________________
const shaderCode = """
// NEW: We now have access to the texture in the fragment stage, with the name that we specify  (aka "tex").
// The Uniforms struct variable "u" will also be available in the shader.

struct VertIn {
  @builtin(vertex_index) id :u32,
  @location(0) pos   :vec3<f32>,
  @location(1) color :vec4<f32>,
  @location(2) uv    :vec2<f32>,
  @location(3) norm  :vec3<f32>,
}
struct VertOut {
  @builtin(position) pos   :vec4<f32>,
  @location(0)       color :vec4<f32>,
  @location(1)       uv    :vec2<f32>,
  @location(2)       norm  :vec3<f32>,
}
@vertex fn vert(in :VertIn) ->VertOut {
  // Add the uniform variable to the position of this vertex
  let offset = 0.3 * vec3<f32>(cos(u.time), sin(u.time), 0.0);  // Calculate the (x,y) offset
  let pos    = in.pos + offset;                                 // Move the vertex position using the offset
  // Define the output of the vertex shader
  var out   :VertOut;
  out.pos   = vec4<f32>(pos, 1.0);
  out.color = in.color;  // Forward the color attribute to the fragment shader
  out.uv    = in.uv;     // Forward the texture coordinates to the fragment shader
  out.norm  = in.norm;   // Forward the vertex normal to the fragment shader
  return out;
}

@fragment fn frag(in :VertOut) ->@location(0) vec4<f32> {
  // return vec4<f32>(u.color.r, u.color.g, u.color.b, in.color.a);
  return textureLoad(tex, vec2<i32>(in.pos.xy), 0);
}
"""

import ngpu/tech/shared/data # TODO: This should be imported auto, but missing RenderData.new( ... )

#________________________________________________
# Entry Point
#__________________
proc run=
  echo "ngpu | Hello Uniform"
  #__________________
  # Init a new Renderer
  e.render = Renderer.new(
    title  = "ngpu | Hello Uniform",
    label  = "ngpu",
    res    = cfg.res,
    key    = key,
    ) # << state.render.init()
  #__________________
  # Init the Data, Mesh and Technique
  var texture  = e.render.new(TexData, img, "tex")           # Create the TexData (no sampler)
  var uniform  = e.render.new(RenderData[Uniforms], u, "u")  # Create the RenderData  (aka uniform)
  var triangle = e.render.new(RenderMesh, gen.triangle())    # Create the RenderMesh
  var tech     = e.render.init(Tech.Simple,
    code = shaderCode,
    data = (uniform,texture).mvar, # The simple tech only accepts a tuple of Group.global data
    ) # << Tech.Simple.init( ... )
  e.render.upload(triangle)
  # Explicit upload step. Could be done when creating the objects (with upload = true)
  e.render.upload(texture)
  e.render.upload(uniform)
  #__________________
  # Update loop
  while not e.render.close():
    # Update the uniform contents
    u.time = glfw.getTime().float32
    e.render.update(uniform, u)
    # Render this mesh, with this style
    e.render.draw(triangle, tech)  # (note: uses any global data contained in the style)
  #__________________
  # Terminate
  e.render.term()


#________________________________________________
when isMainModule: run()

