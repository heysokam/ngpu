# RenderData variables  (aka Shader Uniforms)
## Description
RenderData, like a RenderMesh, is an object  
that contains everything required for the GPU to use its contents in shader code.  

RenderData types for shaders are allowed to be custom types, as long as they fit the requirements.  

To use them, you only need to create a RenderData variable using the ngpu function for it.  
After registering them, the type of your variable and its data will be accesible in your shader code without needing to add shader code for them.  
Their wgsl code is generated automatically by the library when you register the data variable with ngpu.  

Their requirements are:
- Will be read-only on the GPU _(use RenderBlock for writtable data)_.  
- Must be (or contain) wgpu compatible types for data (f32, i32, u32, bool, vecN<T>, matNxN<T>).  
- If the type is an object, each of its fields must be aligned to the size of a `vec4<T>`.  
  _(tip: always use the `{.align(16).}` pragma, and they will be aligned by nim)_  
- The total amount of variables must fit within the per-group binding limits `0..639`.  
- There are a total of `4` groups available.  (the global group will be used by default when omitted)  
  - Groups above 4 are not guaranteed by the spec to exist, and they are locked when using `Limits.default()`.  
    Because of that, group ids `> 3` are just not mapped in this lib.  
  - The mapped groups are:    (0..3 respectively)  
    - Global, Scene, Mesh, Multi  

Because of this, you are meant to provide wgsl code without any structs/bindings defined.  
The code generated by ngpu will be concatenated at the top of your provided shader code.  
_(if they are objects, their struct type definition will also be generated)_.  

## RenderBlock
While RenderData is a type for read-only data specifically,  
the concept of "Block" is used to refer to GPU data that can be both written to and read from.  
A block is data in GPU shader code that can be used for storage (aka writing) and/or reading.  
_This is usually differentiated with "storage block vs uniform block", or "shader storage (ssbo) vs uniform (ubo)" for short._  

While "Data" is a better term for general-purpose data, that includes both writtable and readable contents,  
GPU data is **expected** to be non-writtable by default for optimization purposes.  
As such, while "Block" represents the "uniform"ity of read-only better than "Data",  
this library uses the term Data for read-only contents, just like the GPU expects them to be (unless explicitely specified).  

## Groups
When marking a variable for usage as a RenderData/RenderBlock object,  
you are allowed to (optionally) specify these groups:  
global : Data that never changes, or changes once per frame.  
model  : Data used for an entire model. Changes only on model change.  
mesh   : Data of a single Mesh. Changes each time the Mesh is changed.  
multi  : Data that changes more than once for the same Mesh (multipass).  

Notes:
_The spec only guarantees access to a maximum of `4` groups. So only that amount is exposed._  
_Their names are orientative, and assigned only for clarity/convenience._  
_The default group used will allways be `Group.global` when omitted._  

You don't need to specify a group to bind data to, unless:  
- You are binding more than `640` variables.  
- You really want to optimize GPU access to the variables by grouping them.  
The idea behind this optimization is that variables are grouped by update frequency,  
so that wgpu can use this information to speed things up a bit.  


## Why can't I write the code myself?
The @group(id) and @binding(id) for each specific RenderData entry  
need to be known when the Pipeline of the Rendering Technique is first created.  

If the code wasn't generated automatically, you would need to manually:  
- Create the Technique data and logic, and its respective shader module.  
- Create a Binding Entry for each of the variables used in the shader code.  
- Create the BindGroups Shapes with said entries.  
- Create the PipelineShape, which requires the data of the BindGroups Shapes in advance.  
- And finally create the Pipeline with that shape.  
... which completely defeats the purpose of using this library, since pipeline management is where most of the heavy lifting is done.  

## Why use different words than the "Standard" ones?
See the [internal.md](./internal.md) doc file for an in-depth explanation.  

